Othello artificial intelligence design
The Main class is the main program of the startup. After running the main method, a GameFrame framework will be created, and at the same time, it initializes an indexpanel object to show the main interface of black and white chess.

Gameframe is used to show all the interfaces in the game, showing different pages for different operations for users, and at the same time, when switching on the page, necessary data transmission





One of the most important categories in the project is the ComputerGamepanel class, which covers all the control logic of black and white chess pieces in basic games. In addition, the MCTS class is an encapsulation of artificial intelligence algorithms.




Since many CHESS objects may be stored in memory at the same time, I try to reduce the data occupation of this class as much as possible, and store the status of the chessboard to a 2D integer array. Indicates the color of the chess pieces. We use an ArrayList to store chess -like chess pieces. By traversing the list, we can know the scores that the two sides have obtained.

There are many Create methods in the ComputerGamepanel class to build the necessary elements that need to be displayed in the game interface. By implementing subclasses of the MOUSEADAPTER interface, it is used to monitor the operation of the mouse when the user plays chess, update the drawing of page chess pieces, and re -calculate the current currently calculate the current current The scores of both sides.


I also provide this class as an example of many methods provided by its interface. These methods allow artificial intelligence players to operate and evaluate the layout of chess pieces in the chessboard according to their needs. An important method in the ComputerGamepanel class is the "PossiblePlace" method, which returns an INT array to describe the place where the current player can place the counter; bypass the place where the element value is equal to 1 in this array, that is, the place where you can fall into a drop

The Chess array will be updated as a counter placed at the player at that position. I originally planned to use an integer coordinates to describe the position on the black and white chessboard, but I decided to use the custom Chess object to express it, so that I only need to return an object from any way to provide coordinates.

In addition, I also define the state of Mantype. It indicates whether the next step should be played by the machine or AI chess.
This can be a human player. It receives actions from the user interface of the program, or it can be an Aiplayer. It will decide what actions to play by programming. At the same time, we wrote a Playchesaudiothread class for the sound effects when they settled.

We created five gaming panels such as Aacomputergamepanel and ComputerGamepane to represent the 5 different interfaces of the game, and they are all subclasses of Jpanel. All three panels have the "PAINT" method, which can be used to visualize their interface parts according to the different game status provided. The top and bottom panels also have variables to cache some game status data. There is also a "repain" method to update the interface to update the interface Show. The most notable class is ComputerGamepanel, which needs to be able to detect mouse events to determine the action that the player wants. Therefore, it uses Java's built -in Mouselistener interface, which enables it to receive the MouseEvent object and then convert it into a player's coordinates. There is an important point of note that it is not expressed on the class diagram, that is, these three UI classes are the expansion of the JPANEL class in the Swing package of the Java, which allows me to easily organize their layout in the window. This type of existing method and behavior. The behavior of the MCTs then provided to it in the process of construction. The evaluation device class represents a variety of evaluation functions, which can determine the value of the chess, and the decision -making class is to determine which step should be used by searching for the use of chess steps.


For my project, I decided to use Java programming language. I have used Java many times to complete various homework, so I am very familiar with its working principle. By using Java, I don't need to learn any new programming language for this project, which increases the time I can use for other tasks. This also brings benefits to the final program, that is, it can be played on any operating system that installed the Java virtual machine (JVM). In addition, because Java is an object -oriented programming language, I can easily create and manage various types of games and artificial intelligence, including interfaces between them. It is important to allow the decisioner and appraiser of artificial intelligence at runtime. Finally, Java provides many packages and classes to facilitate creating user interfaces, such as Swing. By using these packages to create the interface, I can quickly create the necessary graphical interface to easily display the game status.
This user interface is designed to be easily implemented in the Java program through the Java Swing, and it can also provide the functions required by black and white chess games. The interface is divided into three parts; the top pane is used to display the current White score, while the bottom pane shows the square score of Black, and at the same time display the game -related information on the upper and lower sides, such as who is currently playing chess. The most important thing is that the middle pane is the main display pane, which contains a black and white chessboard and a counter. At the same time, which player controls which type of counter. This provides human players with a clear image of black and white chessboard (Jeon & Cho, 2018). This page is a place where human players are playing on the chessboard. Just click the blocks they want to do to assume that it is the turn. The entire interface is included in a simple window, and it will be displayed on the user's desktop after starting the program. To determine the maximum/minimum Nextstep method of a game decision tree, the NEXTSTEP method needs to be connected together in a recursion way to call the correct method to correctly evaluate the player or opponent's chess. I ensure that this recursion is correctly set in my pseudo -code to ensure that the implementation version of these functions can work normally. In addition, in order to improve their performance, you need to choose a suitable way to cut pruning; I chose the Alpha-Beta pruning method because it is easy to achieve, and at the same time, it has greatly improved performance. In addition, in order to ensure the end of recursive calls, a basic case is required, and once a certain depth is reached, this process is terminated. This can be regarded as the first line of the above two methods.
UI implementation
After completing the implementation of ComputerGamepanel, I can quickly realize the GUI of the program I want. Thanks to Java's built -in GUI creation package. The final layout of GUI is almost the same as the original draft (see section 3.4), because I am achieving various panels that constitute the game window, and I don't think it is necessary to complicate GUI again; Digital and player scores such as scores are also clearly visible. Compared with the initial design, there are some important changes; the chess player on the black and white chessboard can use the black dot to mark the space, and when the mouse hover reaches the place where the confession, a red square will be displayed to prompt Essence In addition, the score of the current game between the current two sides and the stage of the game are displayed above the screen. Finally, I named the program "Othellotest" and named the color used by the counter in "Ochistaro". Compared with the design phase, the only change is to create an additional frame class named AacomPutergamepanel, which rewritten and optimized the method in the ComputerGamepanel class. This makes the drawing and update methods of each panel bundled together to become a method. Adding this class can also be easier to implement the mouse input function, which allows human players to click on the position of the counter they want to play. Due to the availability and availability of the Java interface class, I did not encounter a big problem when I created the class used by the GUI.
One aspect becomes more complicated than I expected, that is, the black and white procedure can accept the command line parameters to change the game. With the progress of development, more functions need to be changed by users when the program starts. Because AI players need to consist of Node and MCTS classes, they can change these classes-and additional parameters that affect their behavior-it is necessary. In addition, I also want to provide the ability to change other options, such as the visibility of GUI, or whether the game is archived into the text file. In order to do this, I added a piece of code to the black and white chess to analyze the parameters passed to the main method and store each parameter. As long as they follow the format (-x y), in this way There will be related value Y. Then, I added a check to each changeable value in the program and changed the relevant variables. The corresponding parameter label has been passed to the program (Rozani et al., 2019). The main problem of this system is that it requires the parameter to follow strict formats, otherwise the error data will be passed to the program. I have a verification check to ensure that the type and range of the data are correct. If a parameter cannot be accepted, the user will be notified. Due to the flexibility of the program, testing and assessment of the system and its functions is easy to do. Although changing programs can become easier, the current command line parameter system can be used.